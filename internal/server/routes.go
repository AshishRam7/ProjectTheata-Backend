package server

import (
    _"context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/go-chi/cors"
    "github.com/tiktoken-go/tokenizer"
)

// --- Constants ---
const (
    tokenThreshold           = 1// Summarize if text exceeds this many tokens
    defaultChatID            = 1                       // Assume a default chat ID for simplicity
    tokenizerModel           = tokenizer.Cl100kBase    // Tokenizer encoding constant
    maxLogTextLen            = 100                     // Max length of text to log initially
    placeholderSummaryPrefix = "Summary: "            // Prefix for placeholder summary
)

// TranscriptPayload defines the structure for incoming transcript data
type TranscriptPayload struct {
    Speaker   string `json:"speaker"`
    Text      string `json:"text"`
    Timestamp string `json:"timestamp"` // Received as string, allows flexible input format
}

func (s *Server) RegisterRoutes() http.Handler {
    r := chi.NewRouter()
    r.Use(middleware.Logger)
    r.Use(cors.Handler(cors.Options{
        AllowedOrigins:   []string{"https://*", "http://*"},
        AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
        AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
        ExposedHeaders:   []string{"Link"},
        AllowCredentials: true,
        MaxAge:           300,
    }))

    r.Get("/", s.HelloWorldHandler)
    r.Post("/text", s.handleTranscript)
    r.Get("/health", s.healthHandler)

    return r
}

// countTokens estimates the number of tokens in a text using the provided tokenizer.Encoding.
func countTokens(text string, encoding tokenizer.Encoding) (int, error) {
    enc, err := tokenizer.Get(encoding)
    if err != nil {
        return 0, fmt.Errorf("failed to get tokenizer encoding '%s': %w", encoding, err)
    }
    ids, _, err := enc.Encode(text)
    if err != nil {
        return 0, fmt.Errorf("tokenization error: %w", err)
    }
    return len(ids), nil
}

// summarizeText is a PLACEHOLDER for calling a real LLM summarization service.
func summarizeText(text string, provider string) (string, error) {
    log.Printf("Summarizing text (%d chars) using %s...", len(text), provider)
    
    // Return immediately if text is empty
    if len(text) == 0 {
        return "", errors.New("empty text provided for summarization")
    }
    
    switch strings.ToLower(provider) {
    case "openai":
        return summarizeWithOpenAI(text)
    case "gemini":
        return summarizeWithGemini(text)
    default:
        return "", fmt.Errorf("unsupported LLM provider: %s", provider)
    }
}

func summarizeWithOpenAI(text string) (string, error) {
    // Configure OpenAI client
    client := openai.NewClient(os.Getenv("OPENAI_API_KEY"))
    
    // Create completion request
    resp, err := client.CreateChatCompletion(
        context.Background(),
        openai.ChatCompletionRequest{
            Model: "gpt-3.5-turbo",
            Messages: []openai.ChatCompletionMessage{
                {
                    Role:    "system",
                    Content: "You are a helpful assistant that summarizes text concisely.",
                },
                {
                    Role:    "user",
                    Content: "Please summarize the following text:\n\n" + text,
                },
            },
            MaxTokens: 150,
        },
    )
    
    if err != nil {
        return "", fmt.Errorf("openai API error: %w", err)
    }
    
    if len(resp.Choices) == 0 {
        return "", errors.New("no summary generated by OpenAI")
    }
    
    return resp.Choices[0].Message.Content, nil
}

func summarizeWithGemini(text string) (string, error) {
    // Configure Gemini client
    ctx := context.Background()
    client, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv("GEMINI_API_KEY")))
    if err != nil {
        return "", fmt.Errorf("gemini client initialization error: %w", err)
    }
    defer client.Close()
    
    // Get Gemini model
    model := client.GenerativeModel("gemini-pro")
    
    // Configure prompt
    prompt := genai.Text("Please summarize the following text concisely:\n\n" + text)
    
    // Generate content
    resp, err := model.GenerateContent(ctx, prompt)
    if err != nil {
        return "", fmt.Errorf("gemini API error: %w", err)
    }
    
    // Extract summary from response
    if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
        return "", errors.New("no summary generated by Gemini")
    }
    
    summary, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
    if !ok {
        return "", errors.New("unexpected response format from Gemini")
    }
    
    return string(summary), nil
}

func (s *Server) HelloWorldHandler(w http.ResponseWriter, r *http.Request) {
    resp := map[string]string{"message": "Hello World"}
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    _ = json.NewEncoder(w).Encode(resp)
}

func (s *Server) handleTranscript(w http.ResponseWriter, r *http.Request) {
    var payload TranscriptPayload
    if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
        log.Printf("Error decoding transcript payload: %v", err)
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    defer r.Body.Close()

    if payload.Speaker == "" || payload.Text == "" {
        log.Printf("Received incomplete transcript data: Speaker=%q, Text empty=%t", payload.Speaker, payload.Text == "")
        http.Error(w, "Bad Request: Missing speaker or text.", http.StatusBadRequest)
        return
    }

    var parsedTimestamp time.Time
    if payload.Timestamp != "" {
        var err error
        parsedTimestamp, err = time.Parse(time.RFC3339, payload.Timestamp)
        if err != nil {
            log.Printf("Could not parse provided timestamp '%s' with RFC3339: %v. Defaulting to current time.", payload.Timestamp, err)
            parsedTimestamp = time.Now().UTC()
        }
    } else {
        parsedTimestamp = time.Now().UTC()
    }

    logTextPreview := payload.Text
    if len(logTextPreview) > maxLogTextLen {
        logTextPreview = logTextPreview[:maxLogTextLen] + "..."
    }
    log.Printf("[Transcript Received] Speaker: %s, Timestamp: %s, Text Preview: %s",
        payload.Speaker,
        parsedTimestamp.Format(time.RFC3339),
        logTextPreview,
    )

    tokenCount, err := countTokens(payload.Text, tokenizerModel)
    var textToSave string
    if err != nil {
        log.Printf("Error counting tokens for speaker '%s': %v. Proceeding with original text.", payload.Speaker, err)
        textToSave = payload.Text
        tokenCount = -1
    } else {
        log.Printf("Text from '%s' contains approx %d tokens.", payload.Speaker, tokenCount)
        if tokenCount > tokenThreshold {
            log.Printf("Token count (%d) exceeds threshold (%d). Summarizing.", tokenCount, tokenThreshold)
            summary, err := summarizeText(payload.Text)
            if err != nil {
                log.Printf("Error summarizing text for speaker '%s': %v. Saving original text.", payload.Speaker, err)
                textToSave = payload.Text
            } else {
                textToSave = summary
            }
        } else {
            textToSave = payload.Text
        }
    }

    chatID := defaultChatID
    if err := s.db.EnsureChatExists(r.Context(), chatID); err != nil {
        log.Printf("Error ensuring chat exists: %v", err)
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        return
    }

    userID, err := s.db.GetOrCreateChatUserByHandle(r.Context(), payload.Speaker)
    if err != nil {
        log.Printf("Error getting/creating chat user for '%s': %v", payload.Speaker, err)
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        return
    }

    // Pass nil for summary pointer
    if err := s.db.SaveChatLine(r.Context(), chatID, userID, textToSave, nil, parsedTimestamp); err != nil {
        log.Printf("Error saving chat line: %v", err)
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    response := map[string]string{"message": "Transcript received and processed successfully."}
    if textToSave != payload.Text {
        response["note"] = "Text was summarized due to length."
    }
    _ = json.NewEncoder(w).Encode(response)
}

func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) {
    healthStats := s.db.Health()
    w.Header().Set("Content-Type", "application/json")
    if healthStats["status"] != "up" {
        w.WriteHeader(http.StatusInternalServerError)
    } else {
        w.WriteHeader(http.StatusOK)
    }
    _ = json.NewEncoder(w).Encode(healthStats)
}
